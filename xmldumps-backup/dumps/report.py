#!/usr/bin/python3
# Worker process, does the actual dumping
import os
from os.path import exists
import sys
import traceback
import json

from dumps.checksummers import Checksummer
from dumps.fileutils import DumpFilename, FileUtils
from dumps.utils import TimeUtils
from dumps.specialfilesregistry import Registered


class Report(Registered):
    '''
    methods for generation of the index.html file and the json file for a dump
    run for a given wiki and date
    '''
    NAME = "report"
    JSONFILE = "report.json"

    @staticmethod
    def report_dump_step_status(dump_dir, item):
        """Return an HTML fragment and a json object with info on the progress of this dump step."""
        item.status()
        item.updated()
        item.description()
        html = ("<li class='%s'><span class='updates'>%s</span> "
                "<span class='status'>%s</span> <span class='title'>%s</span>" % (
                    item.status(), item.updated(), item.status(), item.description()))
        if item.progress:
            html += "<div class='progress'>%s</div>\n" % item.progress
        dfnames = item.oflister.list_outfiles_to_publish(item.oflister.makeargs(dump_dir))
        if dfnames:
            list_items = [Report.report_file_size_status(dump_dir, dfname, item.status())
                          for dfname in dfnames]
            html += "<ul>"
            detail = item.detail()
            if detail:
                html += "<li class='detail'>%s</li>\n" % detail
            html += "\n".join([entry['txt'] for entry in list_items])
            html += "</ul>"
            json_out = {item.name():
                        {'files':
                         {entry['json']['name']:
                          dict((key, entry['json'][key]) for key in entry['json'] if key != 'name')
                          for entry in list_items}}}
        else:
            json_out = {'job': item.name()}
        html += "</li>"
        content = {'html': html, 'json': json_out}
        return content

    # this is a per-dump-item report (well, per file generated by the item)
    # Report on the file size & item status of the current output and output a link if we are done
    @staticmethod
    def report_file_size_status(dump_dir, dfname, item_status):
        """
        args:
            DumpDir
            DumpFilename
            status ("in-progress", "missing", ...)
        """
        filename = dump_dir.filename_public_path(dfname)
        size = None
        if exists(filename):
            size = os.path.getsize(filename)
        elif item_status == "in-progress":
            # note that because multiple files may be produced for a single dump
            # job, some may be complete while others are still in progress.
            # therefore we check the normal name first, falling back to the
            # inprogress name.
            filename = filename + DumpFilename.INPROG
            if exists(filename):
                try:
                    size = os.path.getsize(filename)
                except Exception:
                    # yes, it might be removed in that short interval of time.
                    pass
        if size is None:
            item_status = "missing"
            size = 0
        pretty_size = FileUtils.pretty_size(size)
        if item_status == "in-progress":
            txt = "<li class='file'>%s %s (written) </li>" % (dfname.filename, pretty_size)
            json_out = {'name': dfname.filename, 'size': size}
        elif item_status == "done":
            webpath_relative = dump_dir.web_path_relative(dfname)
            txt = ("<li class='file'><a href=\"%s\">%s</a> %s</li>"
                   % (webpath_relative, dfname.filename, pretty_size))
            json_out = {'name': dfname.filename, 'size': size,
                        'url': webpath_relative}
        else:
            txt = "<li class='missing'>%s</li>" % dfname.filename
            json_out = {'name': dfname.filename}
        content = {'txt': txt, 'json': json_out}
        return content

    @staticmethod
    def get_jobs(jsoninfo):
        """
        given json output from report file, return the list
        of job names covered in the output
        """
        if jsoninfo is None or "jobs" not in jsoninfo:
            return []
        return jsoninfo['jobs'].keys()

    @staticmethod
    def get_fileinfo_for_job(jobname, reportinfo):
        """
        given json output from report file, and a job name,
        return info about the files associated with that job
        """
        try:
            return reportinfo['jobs'][jobname]["files"]
        except Exception:
            return {}

    @staticmethod
    def get_filenames_for_job(jobname, reportinfo):
        """
        extract from json report info, and return, a list of
        filenames associated with the specific dump job
        """
        return Report.get_fileinfo_for_job(jobname, reportinfo).keys()

    def __init__(self, wiki, enabled, dump_dir=None, items=None, dumpjobdata=None,
                 failhandler=None, error_callback=None, verbose=False):
        super().__init__()
        self.wiki = wiki
        self.dump_dir = dump_dir
        self.items = items
        self.dumpjobdata = dumpjobdata
        self.error_callback = error_callback
        self.verbose = verbose
        self._enabled = enabled
        self.failhandler = failhandler

    @staticmethod
    def add_file_property(jobname, filename, prop, value, reportinfo):
        """
        given json output from report file, a job name, a filename, and
        a property and value, add the property and value to the filename
        specified for the given job
        """
        try:
            if "files" not in reportinfo["jobs"][jobname]:
                reportinfo["jobs"][jobname] = {}
            reportinfo["jobs"][jobname]["files"][filename][prop] = value
        except Exception:
            pass

    def report_previous_dump_link(self, done):
        """Produce a link to the previous dump, if any"""

        # get the list of dumps for this wiki in order, find me in the list,
        # find the one prev to me.
        # why? we might be rerunning a job from an older dumps. we might have two
        # runs going at once (think en pedia, one finishing up the history, another
        # starting at the beginning to get the new stubs).
        try:
            dumps_in_order = self.wiki.latest_dump(return_all=True)
            me_index = dumps_in_order.index(self.wiki.date)
            # don't wrap around to the newest dump in the list!
            if me_index > 0:
                raw_date = dumps_in_order[me_index - 1]
            elif me_index == 0:
                # We are the first item in the list. This is not an error, but there is no
                # previous dump
                return "No prior dumps of this database stored."
            else:
                raise ValueError
        except Exception:
            if self.verbose:
                exc_type, exc_value, exc_traceback = sys.exc_info()
                sys.stderr.write(repr(
                    traceback.format_exception(exc_type, exc_value, exc_traceback)))
            return "No prior dumps of this database stored."
        pretty_date = TimeUtils.pretty_date(raw_date)
        if done:
            prefix = ""
            message = "Last dumped on"
        else:
            prefix = "This dump is in progress; see also the "
            message = "previous dump from"
        return "%s<a href=\"../%s/\">%s %s</a>" % (prefix, raw_date, message, pretty_date)

    def get_checksum_html(self, htype):
        """
        return a string that contains a link to the checksum file for
        the specific hash type (md5 or whatever)
        """
        basename = Checksummer.get_checksum_filename_basename(htype)
        path = DumpFilename(self.wiki, None, basename)
        web_path = self.dump_dir.web_path_relative(path)
        return '<a href="%s">(%s)</a>' % (web_path, htype)

    def update_index_html(self, status_items, dump_status=""):
        '''
        generate index.html file for the wiki's dump run
        containing links to downloads and dump steps status
        '''
        status_items_html = [item['html'] for item in status_items]
        status_items_html.reverse()
        html = "\n".join(status_items_html)
        checksums = [self.get_checksum_html(htype)
                     for htype in Checksummer.HASHTYPES]
        checksums_html = ", ".join(checksums)
        failed_jobs = sum(1 for item in self.items if item.status() == "failed")
        txt = self.wiki.config.read_template("report.html") % {
            "db": self.wiki.db_name,
            "date": self.wiki.date,
            "notice": self.dumpjobdata.notice.notice,
            "status": StatusHtml.report_dump_status(failed_jobs, dump_status),
            "previous": self.report_previous_dump_link(dump_status),
            "items": html,
            "checksum": checksums_html,
            "index": self.wiki.config.index}

        try:
            indexpath = os.path.join(self.wiki.public_dir(), self.wiki.date,
                                     self.wiki.config.perdump_index)
            FileUtils.write_file_in_place(indexpath, txt, self.wiki.config.fileperms)
        except Exception:
            if self.verbose:
                exc_type, exc_value, exc_traceback = sys.exc_info()
                sys.stderr.write(repr(traceback.format_exception(exc_type, exc_value,
                                                                 exc_traceback)))
            message = "Couldn't update index.html file. Continuing anyways"
            if self.error_callback:
                self.error_callback(message)
            else:
                sys.stderr.write("%s\n" % message)

    def update_report_json(self, status_items, dump_status=""):
        '''
        write index json file with info about completed files
        and dump steps status
        '''
        json_out = {'jobs': {}}
        for item in status_items:
            for jobname in item['json']:
                json_out['jobs'][jobname] = item['json'][jobname]
        try:
            json_filepath = os.path.join(self.wiki.public_dir(), self.wiki.date,
                                         Report.JSONFILE)
            FileUtils.write_file_in_place(json_filepath, json.dumps(json_out),
                                          self.wiki.config.fileperms)
        except Exception:
            if self.verbose:
                exc_type, exc_value, exc_traceback = sys.exc_info()
                sys.stderr.write(repr(traceback.format_exception(exc_type, exc_value,
                                                                 exc_traceback)))
            message = "Couldn't update index json file. Continuing anyways"
            if self.error_callback:
                self.error_callback(message)
            else:
                sys.stderr.write("%s\n" % message)

    def update_index_html_and_json(self, dump_status=""):
        '''
        generate the index.html file for the wiki's dump run which contains
        information on each dump step as well as links to completed files
        for download, hash files, etc. and links to completed files;
        generate the json file with the same information as well'''
        if Report.NAME in self._enabled:

            self.dumpjobdata.notice.refresh_notice()
            status_items = [Report.report_dump_step_status(self.dump_dir, item)
                            for item in self.items]
            self.update_index_html(status_items, dump_status)
            self.update_report_json(status_items, dump_status)

    def get_all_output_files(self):
        """
        return list of all report files in all known formats
        """
        files = []
        files.append(self.wiki.config.perdump_index)
        files.append(Report.JSONFILE)
        return files


class StatusHtml(Registered):
    """
    management of the output of wiki dump statuses for each job
    into a status html file
    """
    NAME = "status"

    @staticmethod
    def get_statusfilename():
        """
        return base filename for status html file
        """
        return "status.html"

    @staticmethod
    def report_dump_status(num_jobs_failed, dump_status=""):
        """
        return an html string with the status of the dump
        (still running, failed, done, etc) and the number of items
        failed, if any
        """
        if dump_status == "done":
            classes = "done"
            text = "Dump complete"
        elif dump_status == "partialdone":
            classes = "partial-dump"
            text = "Partial dump"
        else:
            classes = "in-progress"
            text = "Dump in progress"
        if num_jobs_failed > 0:
            classes += " failed"
            if num_jobs_failed == 1:
                ess = ""
            else:
                ess = "s"
            text += ", %d item%s failed" % (num_jobs_failed, ess)
        return "<span class='%s'>%s</span>" % (classes, text)

    @staticmethod
    def get_statusfile_path(wiki, date):
        """
        return the full path to the status html file
        for a dump of the given wiki on the specified date
        """
        return os.path.join(wiki.public_dir(), date, StatusHtml.get_statusfilename())

    @staticmethod
    def status_line(wiki, aborted=False):
        '''
        read the status information from the status html
        file and attempt to return it
        on failure, makes a reasonable guess about the dump status
        and returns that
        if 'aborted' is True, don't read in anything but return
        a line of html that dump was aborted
        '''
        date = wiki.latest_dump()
        if date:
            if aborted:
                return StatusHtml.report_statusline(
                    wiki, "<span class=\"failed\">dump aborted</span>")

            status = StatusHtml.get_statusfile_path(wiki, date)
            try:
                return FileUtils.read_file(status)
            except Exception:
                return StatusHtml.report_statusline(wiki, "missing status record")
        else:
            return StatusHtml.report_statusline(wiki, "has not yet been dumped")

    @staticmethod
    def report_statusline(wiki, status, error=False):
        """
        given a wiki name, the status (done, in progress, etc), produce
        and return a line of html describing the status of the wiki,
        with a link to the wiki dump directory for the dump run date
        if appropriate
        """
        if error:
            # No state information, hide the timestamp
            stamp = "<span style=\"visible: none\">" + TimeUtils.pretty_time() + "</span>"
        else:
            stamp = TimeUtils.pretty_time()
        if wiki.is_private():
            link = "%s (private data)" % wiki.db_name
        else:
            if wiki.date:
                link = "<a href=\"%s/%s\">%s</a>" % (wiki.db_name, wiki.date, wiki.db_name)
            else:
                link = "%s (new)" % wiki.db_name
            if wiki.is_closed():
                link = link + " (closed)"
        return "<li>%s %s: %s</li>\n" % (stamp, link, status)

    @staticmethod
    def write_status(wiki, message):
        """
        get the status information for the wiki dump run for all dump jobs
        and write it into the status html file
        """
        index = StatusHtml.get_statusfile_path(wiki, wiki.date)
        FileUtils.write_file_in_place(index, message, wiki.config.fileperms)

    def __init__(self, wiki, enabled, dump_dir=None, items=None, dumpjobdata=None,
                 failhandler=None, error_callback=None, verbose=False):
        super().__init__()
        self.wiki = wiki
        self.dump_dir = dump_dir
        self.items = items
        self.dumpjobdata = dumpjobdata
        self.error_callback = error_callback
        self.failhandler = failhandler
        self.verbose = verbose
        self._enabled = enabled

    def update_status_file(self, done=False):
        """Write out a status HTML file with the status for this wiki's dump;
        this file is used by the monitor to generate an index.html covering dumps
        of all wikis."""
        if StatusHtml.NAME in self._enabled:

            try:
                # Short line for report extraction goes here
                StatusHtml.write_status(self.wiki, self._report_dump_status_html(done))
            except Exception:
                if self.verbose:
                    exc_type, exc_value, exc_traceback = sys.exc_info()
                    sys.stderr.write(repr(traceback.format_exception(exc_type, exc_value,
                                                                     exc_traceback)))
                message = "Couldn't update status html file. Continuing anyways"
                if self.error_callback:
                    self.error_callback(message)
                else:
                    sys.stderr.write("%s\n" % message)

    def _report_dump_status_html(self, done=False):
        """Put together a brief status summary and link for the current database."""
        failed_jobs = sum(1 for item in self.items if item.status() == "failed")
        status = StatusHtml.report_dump_status(failed_jobs, done)
        html = StatusHtml.report_statusline(self.wiki, status)

        active_items = [x for x in self.items if x.status() == "in-progress"]
        if active_items:
            return html + "<ul>" + "\n".join([
                Report.report_dump_step_status(self.dump_dir, x)['html']
                for x in active_items]) + "</ul>"
        return html

    def get_all_output_files(self):
        '''
        used by the special files registry: return list of all files
        written that are not ordinary dump content files
        '''
        return [self.get_statusfilename()]
